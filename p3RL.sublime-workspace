{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"get_char",
				"get_character_race"
			],
			[
				"play",
				"player_class"
			],
			[
				"stats",
				"stats_component"
			],
			[
				"player",
				"player_performer"
			],
			[
				"moving",
				"moving_entity"
			],
			[
				"ply",
				"player_class"
			],
			[
				"character",
				"character_class"
			],
			[
				"get_",
				"get_character_class"
			],
			[
				"bas",
				"base_max_hp"
			],
			[
				"action",
				"action_free"
			],
			[
				"pl",
				"player_turn_result"
			],
			[
				"targ",
				"target_y"
			],
			[
				"tile",
				"tile_targeting"
			],
			[
				"current",
				"current_game_state"
			],
			[
				"curr",
				"current_game_state"
			],
			[
				"mock",
				"create_mockchar_11"
			],
			[
				"Equip",
				"EquippableFactory"
			],
			[
				"as",
				"assertEqual"
			],
			[
				"tar",
				"target_y"
			],
			[
				"get",
				"get_targetable_entities_in_range"
			],
			[
				"test_pl",
				"test_player_fighter"
			],
			[
				"target",
				"targetable_entity"
			],
			[
				"per",
				"performer_component"
			],
			[
				"feat_",
				"feat_damage_modifier"
			],
			[
				"ta",
				"targeting_message"
			],
			[
				"Effe",
				"EffectNames"
			],
			[
				"create",
				"create_mockchar_5"
			],
			[
				"assert",
				"assertTrue"
			],
			[
				"test_ar",
				"test_arrows_2"
			],
			[
				"Eq",
				"EquippableFactory"
			],
			[
				"equip",
				"equipped_items"
			],
			[
				"Euip",
				"Equipment"
			],
			[
				"Equ",
				"EquippableFactory"
			],
			[
				"Ammu",
				"AmmunitionTypes"
			],
			[
				"missile",
				"missile_weapon_ammunition_lookup"
			],
			[
				"curren",
				"current_targeting_consumable"
			],
			[
				"curre",
				"current_targeting_consumable"
			],
			[
				"defend",
				"defend_missile_attack"
			],
			[
				"defe",
				"defender"
			],
			[
				"get_cu",
				"get_current_missile_damage"
			],
			[
				"melee_",
				"melee_weapon"
			],
			[
				"get_hit",
				"get_hit_modifier_from_equipment"
			],
			[
				"missile_",
				"missile_targeting_weapon"
			],
			[
				"missile_t",
				"missile_targeting"
			],
			[
				"missile_tar",
				"missile_targeting_weapon"
			],
			[
				"spell_",
				"spell_targeting_result"
			],
			[
				"make_fi",
				"make_fireball_scroll"
			],
			[
				"weapon",
				"weapon_category"
			],
			[
				"test",
				"test_entity"
			],
			[
				"skill_check_",
				"skill_check_function_2"
			],
			[
				"get_p",
				"get_physical_damage_modifier_from_equipment"
			],
			[
				"get_hit_",
				"get_hit_modifier_from_status_effects"
			],
			[
				"get_phy",
				"get_physical_damage_modifier_from_status_effects"
			],
			[
				"make_bless",
				"make_bless_spell"
			],
			[
				"kwargs",
				"kwargs"
			],
			[
				"weapon_s",
				"weapon_skill_num"
			],
			[
				"equipp",
				"equippable_entity"
			],
			[
				"prev",
				"previous_game_state"
			],
			[
				"player_turn",
				"player_turn_results"
			],
			[
				"KEY_E",
				"KEY_ENTER"
			],
			[
				"test_pot",
				"test_potion2"
			],
			[
				"ident",
				"identified_scrolls"
			],
			[
				"scroll_desc",
				"scroll_description_links"
			],
			[
				"scr",
				"scroll_descriptions"
			],
			[
				"scroll",
				"scroll_descriptions"
			],
			[
				"consu",
				"consumable_type"
			],
			[
				"test_",
				"test_identified_component"
			],
			[
				"plate_",
				"plate_armor_item"
			],
			[
				"sca",
				"scale_armor_item"
			],
			[
				"chain",
				"chain_armor_item"
			],
			[
				"leat",
				"leather_armor_item"
			],
			[
				"padd",
				"padded_armor_item"
			],
			[
				"tower_s",
				"tower_shield_item"
			],
			[
				"small_",
				"small_shield_item"
			],
			[
				"bol",
				"bolts_item"
			],
			[
				"obs",
				"obsidian_arrows_item"
			],
			[
				"greats",
				"greatsword_item"
			],
			[
				"heal",
				"heal_book_consumable"
			],
			[
				"fireb",
				"fireball_book_consumable"
			],
			[
				"confu",
				"confusion_scroll_consumable"
			],
			[
				"fire",
				"fireball_scroll_consumable"
			],
			[
				"lig",
				"lightning_scroll_consumable"
			],
			[
				"learn",
				"learn_heal"
			],
			[
				"attack_modifier",
				"attack_modifier"
			],
			[
				"heal_bo",
				"heal_book_name"
			],
			[
				"fir",
				"fireball_book_name"
			],
			[
				"padded",
				"padded_armor_entity"
			],
			[
				"player_",
				"player_turn_results"
			],
			[
				"time_",
				"time_results"
			],
			[
				"ligh",
				"lightning_scroll_name"
			],
			[
				"test_ent",
				"test_entity_2"
			],
			[
				"get_basic",
				"get_basic_swing_damage"
			],
			[
				"get_b",
				"get_basic_thrust_damage"
			],
			[
				"effect",
				"effect_list"
			],
			[
				"ef",
				"effect_list"
			],
			[
				"test_effe",
				"test_effect_2"
			],
			[
				"ammu",
				"ammunition_name"
			],
			[
				"id",
				"identified"
			],
			[
				"identi",
				"identified_potions"
			],
			[
				"potion",
				"potion_links"
			],
			[
				"potion_descr",
				"potion_description_links"
			],
			[
				"Item",
				"ItemFactory"
			],
			[
				"effec",
				"effects_component"
			],
			[
				"pot",
				"potion_description_links"
			],
			[
				"potion_",
				"potion_description_links"
			],
			[
				"potion_des",
				"potion_description_links"
			],
			[
				"text",
				"text_menu"
			],
			[
				"shiel",
				"shield_name"
			],
			[
				"miss",
				"missile_weapon"
			],
			[
				"get_skill",
				"get_skill_check"
			],
			[
				"equi",
				"equipment"
			],
			[
				"makeSw",
				"makeGreatSword"
			],
			[
				"equippab",
				"EquippableFactory"
			],
			[
				"makeFire",
				"makeFireballScroll"
			],
			[
				"mis",
				"missile_weapon"
			],
			[
				"player_tur",
				"player_turn_results"
			],
			[
				"missile_d",
				"missile_damage_bonus"
			],
			[
				"cross",
				"crossbow_equippable"
			],
			[
				"rapier",
				"rapier_melee_weapon"
			],
			[
				"melee",
				"melee_weapon"
			],
			[
				"great",
				"greatsword_equippable"
			],
			[
				"mele",
				"melee_attack_type"
			],
			[
				"melee_d",
				"melee_damage_bonus"
			],
			[
				"melee_dam",
				"melee_damage_type"
			],
			[
				"temp_",
				"temp_equippable_missile"
			],
			[
				"Equipp",
				"EquippableFactory"
			],
			[
				"defense",
				"defense_choice"
			],
			[
				"weapon_",
				"weapon_skill_num"
			]
		]
	},
	"buffers":
	[
		{
			"contents": "import unittest\nimport map_objects.tile\nimport entity\nimport tcod as libtcod\nfrom equipment_slots import EquipmentSlots\nimport map_objects.rectangle as rectangle\nfrom components.fighter import Fighter\nfrom components.caster import Caster\nfrom components.equipment import Equipment\nfrom components.equippable import Equippable, EquippableFactory, make_dropped_missile\nfrom components.skills import Skills\nfrom components.stats import Stats\nfrom components.defender import Defender\nfrom components.meleeweapon import MeleeWeapon\nfrom components.item import Item\nfrom components.name import Name\nfrom components.level import Level\nfrom components.identified import Identified\nfrom components.effects import Effect\nfrom components.performer import Performer\nfrom components.consumable import ConsumableTypes, get_carried_potions\nfrom components.inventory import Inventory\nfrom damage_types import DamageTypes\nfrom death_functions import kill_monster\nfrom loader_functions.constants import WeaponTypes, WeaponCategories, get_constants, AmmunitionTypes\nfrom loader_functions.initialize_new_game import get_game_variables, assign_potion_descriptions, assign_scroll_descriptions, populate_dlevels, create_player\nfrom loader_functions.data_loaders import save_game, load_game\nfrom systems.attack import weapon_skill_lookup, get_weapon_skill_for_attack, get_hit_modifier_from_status_effects\nfrom systems.effects_manager import add_effect, tick_down_effects, process_damage_over_time, EffectNames\nfrom systems.name_system import get_display_name\nfrom systems.damage import get_physical_damage_modifier_from_status_effects, get_physical_damage_modifier_from_equipment, apply_physical_damage_modifiers, get_damage_string, get_current_missile_damage, get_current_melee_damage\nfrom systems.attack import get_hit_modifier_from_status_effects, get_hit_modifier_from_equipment, attack\nfrom systems.spell_system import learn_spell, cast, get_spell_target\nfrom systems.skill_manager import SkillNames, get_intellect, get_willpower\nfrom systems.move_system import distance_to\nfrom systems.pickup_system import pickup_item\nfrom systems.feat_system import get_targetable_entities_in_range\nfrom magic_functions import heal, learn_spell_from_book, make_bless_spell\nfrom fov_functions import initialize_fov\nfrom render_functions import get_names_under_mouse\nfrom item_factory import make_healing_potion, make_fireball_scroll, make_confusion_scroll, make_fireball_book, make_heal_book, make_bless_book, make_poison_potion, make_confusion_potion\nfrom components.equippable import EquippableFactory\nimport monsters\nimport mocks\nfrom menus import menu\nimport menu_options\nfrom attack_types import AttackTypes\nfrom menus import get_equipped_items\n\nclass EntityTests(unittest.TestCase):\n	def test_can_make_entity(self):\n		test_entity = entity.Entity(1, 1, 'A', libtcod.white, \"Player\")\n		self.assertEqual(test_entity.x, 1)\n\n	def test_can_make_entity_with_fighter(self):\n		test_fighter = Fighter(xp_reward=10)\n		test_entity = entity.Entity(1, 1, 'A', libtcod.white, \"Player\", fighter=test_fighter)\n		self.assertEqual(test_entity.fighter, test_fighter)\n\n	def test_can_make_entity_with_caster(self):\n		test_caster = Caster(spells=[], max_mana=20)\n		test_entity = entity.Entity(1, 1, 'A', libtcod.white, \"Player\", caster=test_caster)\n		self.assertEqual(test_entity.caster, test_caster)\n		self.assertEqual(test_entity.caster.mana, 20)\n		self.assertEqual(test_entity.caster.max_mana, 20)\n\n	def test_can_make_entity_with_caster_who_knows_spells(self):\n		test_caster = Caster(spells=[], max_mana=50)\n		test_entity = entity.Entity(1, 1, 'A', libtcod.white, \"Player\", caster=test_caster)\n		learn_spell(test_entity, 'fireball')\n		self.assertEqual(test_caster.spells[0].name, \"Fireball\")\n\nclass SpellTests(unittest.TestCase):\n	def test_can_learn_heal(self):\n		test_caster = Caster(spells=[], max_mana=50)\n		test_entity = entity.Entity(1, 1, 'A', libtcod.white, \"Player\", caster=test_caster)\n		learn_spell(test_entity, 'heal')\n		self.assertEqual(test_caster.spells[0].name, \"Heal\")\n\n	def test_can_learn_bless(self):\n		test_caster = Caster(spells=[], max_mana=50)\n		test_entity = entity.Entity(1, 1, 'A', libtcod.white, \"Player\", caster=test_caster)\n		learn_spell(test_entity, 'bless')\n		self.assertEqual(test_caster.spells[0].name, \"Bless\")\n\n	def test_can_learn_bless_from_book(self):\n		test_caster = Caster(spells=[], max_mana=50)\n		test_entity = entity.Entity(1, 1, 'A', libtcod.white, \"Player\", caster=test_caster)\n		learn_spell_from_book(test_entity, spell_name='bless')\n		self.assertEqual(test_caster.spells[0].name, \"Bless\")\n\n	def test_can_learn_multiple_spells(self):\n		test_caster = Caster(spells=[], max_mana=50)\n		test_entity = entity.Entity(1, 1, 'A', libtcod.white, \"Player\", caster=test_caster)\n		learn_spell(test_entity, 'heal')\n		learn_spell(test_entity, 'fireball')\n		self.assertEqual(test_caster.spells[0].name, \"Heal\")\n		self.assertEqual(test_caster.spells[1].name, \"Fireball\")\n\n	def test_can_cast_bless_spell_with_high_skill(self):\n		test_caster = Caster(spells=[], max_mana=50)\n		test_fighter = Fighter(xp_reward=100)\n		test_stats = Stats()\n		test_skills = Skills()\n		test_skills.set_skill_rank(SkillNames.HOLY, 8)\n		test_entity = entity.Entity(1, 1, 'A', libtcod.white, \"Player\", caster=test_caster, fighter=test_fighter, skills=test_skills, stats=test_stats)\n		entities = []\n		entities.append(test_entity)\n		spell = make_bless_spell()\n		results = cast(test_entity, spell, target_x=1, target_y=1, entities=entities)\n		self.assertTrue(len(results), 1)\n		self.assertEqual(len(test_entity.fighter.effect_list), 1)\n		self.assertEqual(test_entity.fighter.effect_list[0].name, EffectNames.BLESS)\n		self.assertEqual(test_entity.fighter.effect_list[0].turns_left, 25)\n		self.assertEqual(get_hit_modifier_from_status_effects(test_entity), 1)\n		self.assertEqual(get_physical_damage_modifier_from_status_effects(test_entity), 1)\n\n	def test_cannot_cast_bless_spell_with_no_skill(self):\n		test_caster = Caster(spells=[], max_mana=50)\n		test_fighter = Fighter(xp_reward=100)\n		test_stats = Stats(Strength=1, Precision=1, Agility=1, Intellect=1, Willpower=1, Stamina=1, Endurance=1)\n		test_skills = Skills()\n		test_entity = entity.Entity(1, 1, 'A', libtcod.white, \"Player\", caster=test_caster, fighter=test_fighter, skills=test_skills, stats=test_stats)\n		entities = []\n		entities.append(test_entity)\n		spell = make_bless_spell()\n		results = cast(test_entity, spell, target_x=1, target_y=1, entities=entities)\n		self.assertTrue(len(results), 1)\n		self.assertEqual(len(test_entity.fighter.effect_list), 0)\n\n	def test_can_get_spell_target(self):\n		constants = get_constants()\n		player, entities, game_map, message_log, game_state, dlevels = get_game_variables(constants)\n		fov_map = initialize_fov(game_map)\n		test_monster = mocks.create_mockchar_11()\n		test_monster.x, test_monster.y = 2, 2\n		entities = [player, test_monster]\n		self.assertEqual(get_spell_target(player, 2, 2, entities, fov_map), test_monster)\n\n	def test_cannot_get_spell_target_out_of_range(self):\n		constants = get_constants()\n		player, entities, game_map, message_log, game_state, dlevels = get_game_variables(constants)\n		fov_map = initialize_fov(game_map)\n		test_monster = mocks.create_mockchar_11()\n		test_monster.x, test_monster.y = 10, 10\n		entities = [player, test_monster]\n		self.assertEqual(get_spell_target(player, 2, 2, entities, fov_map), None)\n\nclass EquipmentTests(unittest.TestCase):\n	def test_can_equip_main_hand(self):\n		test_equipment = Equipment()\n		test_player_entity = entity.Entity(1, 1, 'A', libtcod.white, \"Player\", equipment=test_equipment)\n		test_item_entity = EquippableFactory.make_longsword()\n		test_equipment.toggle_equip(test_item_entity)\n		self.assertEqual(test_player_entity.equipment.main_hand.equippable, test_item_entity.equippable)\n\n	def test_can_create_equipment_component(self):\n		test_equipment = Equipment()\n		test_entity = entity.Entity(1, 1, 'A', libtcod.white, \"Player\", equipment=test_equipment)\n		self.assertEqual(test_entity.equipment.main_hand, None)\n		self.assertEqual(test_entity.equipment.off_hand, None)\n		self.assertEqual(test_entity.equipment.body, None)\n		self.assertEqual(test_entity.equipment.ammunition, None)\n\n	def test_can_get_equipped_items(self):\n		test_equipment = Equipment()\n		test_char = entity.Entity(1, 1, 'A', libtcod.white, \"Player\", equipment=test_equipment)\n		self.assertEqual(len(get_equipped_items(test_char)), 4)\n\nclass SkillsTests(unittest.TestCase):\n	def test_can_create_and_link_skills_component(self):\n		test_skillset = Skills()\n		test_entity = entity.Entity(1, 1, 'A', libtcod.white, \"Player\", skills=test_skillset)\n		self.assertEqual(test_entity.skills, test_skillset)\n	 \n	def test_can_create_sword_skill(self):\n		test_skillset = Skills()\n		test_skillset.set_skill_rank(\"sword\", 1)\n		self.assertEqual(test_skillset.skills[\"sword\"], 1)\n\n	def test_can_update_sword_skill(self):\n		test_skillset = Skills()\n		test_skillset.set_skill_rank(\"sword\", 1)\n		test_skillset.set_skill_rank(\"sword\", 3)\n		self.assertEqual(test_skillset.skills[\"sword\"], 3)\n\n	def test_can_get_skill(self):\n		test_skillset = Skills()\n		test_stats = Stats()\n		test_entity = entity.Entity(1, 1, 'A', libtcod.white, \"Player\", stats=test_stats, skills=test_skillset)\n		test_skillset.set_skill_rank(SkillNames.SWORD, 1)\n		skill_test = test_skillset.get_skill_check(SkillNames.SWORD)\n		self.assertEqual(skill_test, 10)\n	\n	def test_can_get_default(self):\n		test_skillset = Skills()\n		test_stats = Stats()\n		test_entity = entity.Entity(1, 1, 'A', libtcod.white, \"Player\", stats=test_stats, skills=test_skillset)\n		skill_test = test_skillset.get_skill_check(SkillNames.SWORD)\n		self.assertEqual(skill_test, 6)\n\nclass StatsTests(unittest.TestCase):\n	def test_can_create_entity_with_stats(self):\n		test_stats_component = Stats(Strength=9, Precision=11, Agility=12, Intellect=10, Willpower=9, Stamina=10, Endurance=9)\n		test_entity = entity.Entity(1, 1, 'A', libtcod.white, \"Player\", stats=test_stats_component)\n		self.assertEqual(test_entity.stats, test_stats_component)\n\n	def test_can_calculate_hp(self):\n		test_stats_component = Stats(Strength=9, Precision=11, Agility=12, Intellect=10, Willpower=9, Stamina=10, Endurance=9)\n		test_entity = entity.Entity(1, 1, 'A', libtcod.white, \"Player\", stats=test_stats_component)\n		self.assertEqual(test_entity.stats.max_hp, 19)\n		self.assertEqual(test_entity.stats.hp, 19)\n\n	def test_can_go_up_a_level(self):\n		test_fighter = Fighter()\n		test_level = Level()\n		test_stats = Stats(Strength=9, Precision=11, Agility=12, Intellect=10, Willpower=9, Stamina=10, Endurance=9)\n		test_entity = entity.Entity(1, 1, 'A', libtcod.white, \"Player\", fighter=test_fighter, level=test_level, stats=test_stats)\n		self.assertTrue(test_level.current_level, 1)\n		self.assertFalse(test_level.add_xp(1))\n		self.assertTrue(test_stats.Endurance, 9)\n		self.assertTrue(test_level.add_xp(200))\n		self.assertTrue(test_level.current_level, 2)\n		test_level.level_up()\n		self.assertTrue(test_stats.Endurance, 10)\n\n	def test_hp_regen_amount_works(self):\n		test_fighter = Fighter()\n		test_level = Level()\n		test_stats = Stats(Strength=9, Precision=11, Agility=12, Intellect=10, Willpower=9, Stamina=10, Endurance=10)\n		test_entity = entity.Entity(1, 1, 'A', libtcod.white, \"Player\", fighter=test_fighter, level=test_level, stats=test_stats)\n		self.assertEqual(test_entity.stats.hp_regen_amount, 0.1)\n\n	def test_hp_regen_bonus_works_with_equipment(self):\n		test_equipment = Equipment()\n		padded_armor_equippable = Equippable(EquipmentSlots.BODY, DR_bonus=1, hp_regen_bonus=0.1)\n		padded_armor_name = Name(\"Padded Armor\")\n		padded_armor_entity = entity.Entity(1, 1, ')', libtcod.purple, equippable=padded_armor_equippable, name=padded_armor_name)\n		test_fighter = Fighter()\n		test_level = Level()\n		test_stats = Stats(Strength=9, Precision=11, Agility=12, Intellect=10, Willpower=9, Stamina=10, Endurance=10)\n		test_entity = entity.Entity(1, 1, 'A', libtcod.white, \"Player\", fighter=test_fighter, level=test_level, stats=test_stats, equipment=test_equipment)\n		test_equipment.body = padded_armor_entity\n		self.assertEqual(test_equipment.hp_regen_bonus, 0.1)\n		self.assertEqual(test_entity.stats.hp_regen_amount, 0.2)\n\n	def test_sp_regen_amount_works(self):\n		test_fighter = Fighter()\n		test_level = Level()\n		test_stats = Stats(Strength=9, Precision=11, Agility=12, Intellect=10, Willpower=9, Stamina=10, Endurance=10)\n		test_entity = entity.Entity(1, 1, 'A', libtcod.white, \"Player\", fighter=test_fighter, level=test_level, stats=test_stats)\n		self.assertEqual(test_entity.stats.sp_regen_amount, 0.1)\n\n	def test_sp_regen_bonus_works_with_equipment(self):\n		test_equipment = Equipment()\n		padded_armor_equippable = Equippable(EquipmentSlots.BODY, DR_bonus=1, sp_regen_bonus=0.1)\n		padded_armor_name = Name(\"Padded Armor\")\n		padded_armor_entity = entity.Entity(1, 1, ')', libtcod.purple, equippable=padded_armor_equippable, name=padded_armor_name)\n		test_fighter = Fighter()\n		test_level = Level()\n		test_stats = Stats(Strength=9, Precision=11, Agility=12, Intellect=10, Willpower=9, Stamina=10, Endurance=10)\n		test_entity = entity.Entity(1, 1, 'A', libtcod.white, \"Player\", fighter=test_fighter, level=test_level, stats=test_stats, equipment=test_equipment)\n		test_equipment.body = padded_armor_entity\n		self.assertEqual(test_equipment.sp_regen_bonus, 0.1)\n		self.assertEqual(test_entity.stats.sp_regen_amount, 0.2)\n\n	def test_mana_regen_amount_works(self):\n		test_fighter = Fighter()\n		test_level = Level()\n		test_stats = Stats(Strength=9, Precision=11, Agility=12, Intellect=10, Willpower=10, Stamina=10, Endurance=10)\n		test_entity = entity.Entity(1, 1, 'A', libtcod.white, \"Player\", fighter=test_fighter, level=test_level, stats=test_stats)\n		self.assertEqual(test_entity.stats.mana_regen_amount, 0.1)\n\n	def test_mana_regen_bonus_works_with_equipment(self):\n		test_equipment = Equipment()\n		padded_armor_equippable = Equippable(EquipmentSlots.BODY, DR_bonus=1, mana_regen_bonus=0.1)\n		padded_armor_name = Name(\"Padded Armor\")\n		padded_armor_entity = entity.Entity(1, 1, ')', libtcod.purple, equippable=padded_armor_equippable, name=padded_armor_name)\n		test_fighter = Fighter()\n		test_level = Level()\n		test_stats = Stats(Strength=9, Precision=11, Agility=12, Intellect=10, Willpower=10, Stamina=10, Endurance=10)\n		test_entity = entity.Entity(1, 1, 'A', libtcod.white, \"Player\", fighter=test_fighter, level=test_level, stats=test_stats, equipment=test_equipment)\n		test_equipment.body = padded_armor_entity\n		self.assertEqual(test_equipment.mana_regen_bonus, 0.1)\n		self.assertEqual(test_entity.stats.mana_regen_amount, 0.2)\n\nclass DamageTests(unittest.TestCase):\n	def test_can_calculate_physical_damage_modifier_from_equipment(self):\n		test_equipment = Equipment()\n		padded_armor_equippable = Equippable(EquipmentSlots.BODY, DR_bonus=1, physical_damage_modifier=2)\n		padded_armor_name = Name(\"Padded Armor\")\n		padded_armor_entity = entity.Entity(1, 1, ')', libtcod.purple, equippable=padded_armor_equippable, name=padded_armor_name)\n		test_entity = entity.Entity(1, 1, 'A', libtcod.white, \"Player\", equipment=test_equipment)\n		test_equipment.body = padded_armor_entity\n		self.assertEqual(get_physical_damage_modifier_from_equipment(test_entity), 2)\n\n	def test_can_calculate_damage_bonus_from_effects(self):\n		test_caster = Caster(spells=[], max_mana=50)\n		test_entity = entity.Entity(1, 1, 'A', libtcod.white, \"Player\", caster=test_caster)\n		learn_spell(test_entity, 'bless')\n\n	def test_can_apply_damage_modifiers(self):\n		test_equipment = Equipment()\n		test_fighter = Fighter(xp_reward=100)\n		padded_armor_equippable = Equippable(EquipmentSlots.BODY, DR_bonus=1, physical_damage_modifier=2)\n		padded_armor_name = Name(\"Padded Armor\")\n		padded_armor_entity = entity.Entity(1, 1, ')', libtcod.purple, equippable=padded_armor_equippable, name=padded_armor_name)\n		test_entity = entity.Entity(1, 1, 'A', libtcod.white, \"Player\", equipment=test_equipment, fighter=test_fighter)\n		test_equipment.body = padded_armor_entity\n		modifier = 0\n		modifier += apply_physical_damage_modifiers(modifier, test_entity)\n		self.assertEqual(modifier, 2)\n\n	def test_can_get_damage_string(self):\n		test_stats_component = Stats(Strength=9, Precision=11, Agility=12, Intellect=10, Willpower=9, Stamina=10, Endurance=9)\n		test_fighter_component = Fighter(xp_reward=10)\n		test_equipment = Equipment()\n		test_entity = entity.Entity(1, 1, 'A', libtcod.white, \"Player\", stats=test_stats_component, fighter=test_fighter_component, equipment=test_equipment)\n		self.assertTrue(\"d\" in get_damage_string(test_entity))\n\nclass AttackTests(unittest.TestCase):\n	def test_can_lookup_weapon_skill(self):\n		test_weapon = EquippableFactory.make_longsword()\n		self.assertEqual(weapon_skill_lookup(test_weapon), SkillNames.SWORD)\n		test_weapon2 = EquippableFactory.make_greatsword()\n		self.assertEqual(weapon_skill_lookup(test_weapon2), SkillNames.SWORD)\n\n	def test_can_lookup_correct_weapon_skill(self):\n		test_char = mocks.create_mockchar_3()\n		weapon = test_char.equipment.main_hand\n		skill_num = get_weapon_skill_for_attack(test_char)\n		self.assertEqual(skill_num, 10)\n\n	def test_can_lookup_unarmed_skill_if_no_weapon(self):\n		test_char = mocks.create_mockchar_12()\n		skill_num = get_weapon_skill_for_attack(test_char)\n		self.assertEqual(skill_num, 13)\n\n	def test_can_get_equipment_attack_bonus(self):\n		test_equipment = Equipment()\n		padded_armor_equippable = Equippable(EquipmentSlots.BODY, DR_bonus=1, hit_modifier=2)\n		padded_armor_name = Name(\"Padded Armor\")\n		padded_armor_entity = entity.Entity(1, 1, ')', libtcod.purple, equippable=padded_armor_equippable, name=padded_armor_name)\n		test_entity = entity.Entity(1, 1, 'A', libtcod.white, \"Player\", equipment=test_equipment)\n		test_equipment.body = padded_armor_entity\n		self.assertEqual(get_hit_modifier_from_equipment(test_entity), 2)\n\n	def test_can_perform_melee_attack(self):\n		test_char = mocks.create_mockchar_3()\n		test_enemy = mocks.create_mockchar_3()\n		results = attack(test_char, test_enemy, AttackTypes.MELEE)\n		self.assertNotEqual(len(results), 0)\n\n	def test_can_perform_attack_with_feat_bonuses(self):\n		#TODO: Make this testable somehow!\n		pass\n\nclass DefenderTests(unittest.TestCase):\n	def test_can_create_defender(self):\n		test_defender_component = Defender()\n		test_entity = entity.Entity(1, 1, 'A', libtcod.white, \"Player\", defender=test_defender_component)\n		self.assertEqual(test_entity.defender, test_defender_component)\n\n	def test_can_get_correct_parry(self):\n		test_char = mocks.create_mockchar_3()\n		self.assertEqual(test_char.defender.get_parry(), 5)\n\n	def test_can_get_correct_block(self):\n		test_char = mocks.create_mockchar_5()\n		self.assertEqual(test_char.defender.get_block(), 5)\n\n	def test_can_get_correct_evade(self):\n		test_char = mocks.create_mockchar_2()\n		self.assertEqual(test_char.defender.get_evade(), 5)\n\n	def test_defender_can_provide_a_defense(self):\n		test_char = mocks.create_mockchar_2()\n		defense_num = test_char.defender.get_best_melee_defense()\n		self.assertNotEqual(defense_num, 0)\n\n	def test_defender_can_choose_best_melee_defense_without_shield(self):\n		test_char = mocks.create_mockchar_3()\n		results = test_char.defender.get_best_melee_defense()\n		self.assertEqual(results[0], \"parry\")\n		self.assertEqual(results[1], 5)\n\n	#def test_defender_can_choose_best_melee_defense_with_shield_and_low_shield_skill(self):\n	#	test_char = mocks.create_mockchar_5()\n	#	results = test_char.defender.get_best_melee_defense()\n	#	self.assertEqual(results[0], \"parry\")\n	#	self.assertEqual(results[1], 6)		\n\n	def test_defender_can_choose_best_melee_defense_with_shield_and_high_shield_skill(self):\n		test_char = mocks.create_mockchar_6()\n		results = test_char.defender.get_best_melee_defense()\n		self.assertEqual(test_char.skills.get_skill_check(SkillNames.SHIELD), 10)\n		self.assertEqual(results[0], \"block\")\n		self.assertEqual(results[1], 5)\n\n	def test_defender_can_choose_best_missile_defense(self):\n		test_char = mocks.create_mockchar_1()\n		results = test_char.defender.get_best_missile_defense()\n		self.assertEqual(results[0], \"evade\")\n		self.assertEqual(results[1], 5)\n\n	def test_defender_can_choose_best_missile_defense_but_not_a_parry(self):\n		test_char = mocks.create_mockchar_5()\n		results = test_char.defender.get_best_missile_defense()\n		self.assertNotEqual(results[0], \"parry\")\n\n	def test_defender_can_choose_best_missile_defense_with_shield(self):\n		test_char = mocks.create_mockchar_11()\n		results = test_char.defender.get_best_missile_defense()\n		self.assertEqual(results[0], \"block\")\n		self.assertEqual(results[1], 7)\n\nclass DeathTests(unittest.TestCase):\n	def test_killing_a_monster_gives_xp(self):\n		# TODO: write this test\n		test_char = mocks.create_mockchar_11()\n		test_monster = monsters.make_orc(1, 1)\n		self.assertEqual(test_char.level.current_xp, 0)\n		message = message, test_char = kill_monster(test_monster, test_char)\n		self.assertGreater(test_char.level.current_xp, 0)\n\nclass DeathDropTests(unittest.TestCase):\n	def test_monster_has_items(self):\n		test_monster = monsters.make_kobold(1, 1)\n		self.assertNotEqual(len(test_monster.inventory.items), 0)\n\n	def test_kobold_drops_all_items(self):\n		test_monster = monsters.make_kobold(1, 1)\n		entities = []\n		entities = test_monster.inventory.drop_on_death(entities, test_monster)\n		self.assertEqual(len(entities), 3)\n\n	def test_orc_drops_all_items(self):\n		test_monster = monsters.make_orc(1, 1)\n		entities = []\n		entities = test_monster.inventory.drop_on_death(entities, test_monster)\n		self.assertEqual(len(entities), 2)\n\nclass DroppedMissileTests(unittest.TestCase):\n	def test_can_drop_missile(self):\n		test_monster = monsters.make_kobold(1, 1)\n		entities = []\n		entities.append(make_dropped_missile(AmmunitionTypes.ARROWS, (1,1)))\n		self.assertEqual(len(entities), 1)\n\n	def test_can_drop_missile_at_correct_location(self):\n		test_monster = monsters.make_kobold(1, 1)\n		entities = []\n		entities.append(make_dropped_missile(AmmunitionTypes.ARROWS, (1,1)))\n		self.assertEqual(entities[0].x, 1)\n		self.assertEqual(entities[0].y, 1)\n		self.assertEqual(entities[0].name.true_name, \"Arrow\")\n\nclass MissileWeaponTests(unittest.TestCase):\n	def test_can_create_arrows(self):\n		test_arrows = EquippableFactory.make_arrows(1, 1, 10)\n		self.assertEqual(test_arrows.item.quantity, 10)\n\n	def test_can_equip_missile_weapon(self):\n		test_char = mocks.create_mockchar_1()\n		test_bow = EquippableFactory.make_shortbow()\n		test_char.equipment.toggle_equip(test_bow)\n		self.assertEqual(test_char.equipment.main_hand, test_bow)\n		self.assertNotEqual(test_char.equipment.main_hand.missile_weapon.missile_damage, None)\n\n	def test_can_load_missile_weapon(self):\n		test_char = mocks.create_mockchar_10()\n		test_char.fighter.load_missile_weapon()\n		self.assertEqual(test_char.equipment.main_hand.missile_weapon.loaded, True)\n\n	def test_cannot_load_missile_weapon_without_ammunition(self):\n		test_char = mocks.create_mockchar_9()\n		results = test_char.fighter.load_missile_weapon()\n		self.assertEqual(results[0].get(\"loaded\"), None)\n\n	def test_can_get_missile_weapon_damage(self):\n		test_char = mocks.create_mockchar_1()\n		test_bow = EquippableFactory.make_shortbow()\n		test_char.equipment.toggle_equip(test_bow)\n		self.assertEqual(get_current_missile_damage(test_char), (1,6,0, DamageTypes.PIERCING))\n\n	def test_can_check_if_has_ammunition(self):\n		test_char = mocks.create_mockchar_10()\n		self.assertEqual(test_char.equipment.has_ammunition(), True)\n\n	def test_has_ammunition_returns_false_if_no_arrows(self):\n		test_char = mocks.create_mockchar_9()\n		self.assertEqual(test_char.equipment.has_ammunition(), False)		\n\nclass MeleeWeaponTests(unittest.TestCase):\n	def test_can_create_melee_weapon_component(self):\n		test_component = MeleeWeapon(WeaponTypes.AXE, WeaponCategories.AXE, \"swing\", 1, DamageTypes.CRUSHING)\n		self.assertEqual(test_component.weapon_type, WeaponTypes.AXE)\n\n	def test_has_melee_weapon(self):\n		test_char = mocks.create_mockchar_5()\n		self.assertEqual(test_char.equipment.has_melee_weapon(), True)\n	\n	def test_can_get_current_melee_damage(self):\n		test_char = mocks.create_mockchar_5()\n		self.assertEqual(get_current_melee_damage(test_char), (1,6,0, DamageTypes.SLASHING))	\n\n\nclass NameTests(unittest.TestCase):\n	def test_can_make_name_with_display(self):\n		test_name = Name(\"foo\")\n		test_entity = entity.Entity(1, 1, 'A', libtcod.white, name=test_name)\n		self.assertEqual(test_name.true_name, \"foo\")\n\n	def test_can_make_name_with_true_name(self):\n		test_name = Name(true_name=\"bar\")\n		self.assertEqual(test_name.true_name, \"bar\")\n\n	def test_can_make_entity_with_names(self):\n		test_name_component = Name(true_name=\"true\")\n		test_entity = entity.Entity(1, 1, 'A', libtcod.white, name=test_name_component)\n		self.assertEqual(test_entity.name.true_name, \"true\")\n\n#class ItemTests(unittest.TestCase):\n#	def test_can_create_item(self):\n#		test_item_component = Item(use_function=None, targeting=False, targeting_message=None)\n#		test_entity = entity.Entity(1, 1, 'A', libtcod.white, \"Test\", item=test_item_component)\n#		self.assertEqual(test_item_component, test_entity.item)\n\n#	def test_can_create_healing_potion(self):\n#		test_item = ItemFactory.makeHealingPotion()\n#		self.assertEqual(test_item.name, \"Healing Potion\")\n\nclass GetGameVariablesTests(unittest.TestCase):\n	def test_can_create_player(self):\n		constants = get_constants()\n		player, entities, game_map, message_log, game_state, dlevels = get_game_variables(constants)\n		self.assertEqual(player.name.true_name, \"Player\")\n\n	def test_can_create_entities(self):\n		constants = get_constants()\n		player, entities, game_map, message_log, game_state, dlevels = get_game_variables(constants)\n		self.assertEqual(isinstance(entities, list), True)\n\n	def test_can_create_game_map(self):\n		constants = get_constants()\n		player, entities, game_map, message_log, game_state, dlevels = get_game_variables(constants)\n		self.assertNotEqual(game_map, None)\n\n	def test_can_create_message_log(self):\n		constants = get_constants()\n		player, entities, game_map, message_log, game_state, dlevels = get_game_variables(constants)\n		self.assertNotEqual(message_log, None)	\n\n	def test_can_create_game_state(self):\n		constants = get_constants()\n		player, entities, game_map, message_log, game_state, dlevels = get_game_variables(constants)\n		self.assertNotEqual(game_state, None)\n\n	def test_can_create_dlevels(self):\n		constants = get_constants()\n		player, entities, game_map, message_log, game_state, dlevels = get_game_variables(constants)\n		self.assertNotEqual(dlevels, None)\n\n	def test_can_populate_dlevels(self):\n		constants = get_constants()\n		player, entities, game_map, message_log, game_state, dlevels = get_game_variables(constants)\n		dlevels = populate_dlevels(entities, game_map, 6)\n		self.assertTrue(1 in dlevels.keys())\n		self.assertTrue(6 in dlevels.keys())\n		self.assertTrue(7 not in dlevels.keys())\n\n#class MenuTests(unittest.TestCase):\n#	def can_create_main_menu(self):\n#		constants = get_constants()\n#		options = build_text_menu(['Play a new game', 'Continue a game', 'Quit'])\n#		con = libtcod.console_new(constants['screen_width'], constants['screen_height'])\n##		main_menu(con, main_menu_background_image, constants['screen_width'], constants['screen_height'])\n\nclass ItemNamesTests(unittest.TestCase):\n	def test_player_has_lists_of_identified_items(self):\n		dummy_links = {}\n		identified_component = Identified(dummy_links)\n		self.assertTrue(isinstance(identified_component.identified_potions, list), True)\n		self.assertTrue(isinstance(identified_component.identified_scrolls, list), True)\n		self.assertTrue(isinstance(identified_component.potion_links, dict), True)\n\n	def test_game_has_list_of_potion_names(self):\n		constants = get_constants()\n		self.assertNotEqual(len(constants['potion_descriptions']), 0)\n\n	def test_game_has_list_of_scroll_names(self):\n		constants = get_constants()\n		self.assertNotEqual(len(constants['scroll_descriptions']), 0)\n\n	def test_game_has_list_of_potion_types(self):\n		constants = get_constants()\n		self.assertNotEqual(len(constants['potion_types']), 0)\n\n	def test_game_has_list_of_scroll_types(self):\n		constants = get_constants()\n		self.assertNotEqual(len(constants['scroll_types']), 0)	\n\n	def test_same_number_of_potion_names_and_types(self):\n		constants = get_constants()\n		self.assertEqual(len(constants['potion_descriptions']), len(constants['potion_types']))\n\n	def test_same_number_of_scroll_names_and_types(self):\n		constants = get_constants()\n		self.assertEqual(len(constants['scroll_descriptions']), len(constants['scroll_types']))	\n\n	def test_can_assign_a_potion_name_to_a_type(self):\n		constants = get_constants()\n		potion_description_links = assign_potion_descriptions(constants['potion_descriptions'], constants['potion_types'])\n		self.assertNotEqual(len(potion_description_links), 0)\n\n	def test_can_assign_a_scroll_name_to_a_type(self):\n		constants = get_constants()\n		scroll_description_links = assign_scroll_descriptions(constants['scroll_descriptions'], constants['scroll_types'])\n		self.assertNotEqual(len(scroll_description_links), 0)\n\n	def test_player_has_potion_links(self):\n		constants = get_constants()\n		potion_description_links = assign_potion_descriptions(constants['potion_descriptions'], constants['potion_types'])\n		test_identified_component = Identified(potion_description_links)\n		test_entity = entity.Entity(1, 1, 'A', libtcod.white, identified=test_identified_component)\n		self.assertEqual(isinstance(test_entity.identified.potion_links, dict), True)\n\n	def test_player_has_scroll_links(self):\n		constants = get_constants()\n		scroll_description_links = assign_scroll_descriptions(constants['scroll_descriptions'], constants['scroll_types'])\n		potion_description_links = assign_potion_descriptions(constants['potion_descriptions'], constants['potion_types'])\n		test_identified_component = Identified(potion_description_links, scroll_description_links)\n		test_entity = entity.Entity(1, 1, 'A', libtcod.white, identified=test_identified_component)\n		self.assertEqual(isinstance(test_entity.identified.scroll_links, dict), True)\n\n	def test_identified_potion_has_correct_display_name(self):\n		constants = get_constants()\n		potion_description_links = assign_potion_descriptions(constants['potion_descriptions'], constants['potion_types'])\n		test_identified_component = Identified(potion_description_links)\n		test_identified_component.identified_potions.append(\"Healing Potion\")\n		test_player = entity.Entity(1, 1, 'A', libtcod.white, identified=test_identified_component)\n		test_potion = make_healing_potion()\n		self.assertEqual(test_potion.name.true_name, \"Healing Potion\")\n		self.assertTrue(\"Healing Potion\" in test_player.identified.identified_potions)\n		self.assertEqual(get_display_name(test_player, test_potion), \"Healing Potion\")\n\n	def test_unidentified_potion_has_correct_display_name(self):\n		constants = get_constants()\n		potion_description_links = assign_potion_descriptions(constants['potion_descriptions'], constants['potion_types'])\n		test_identified_component = Identified(potion_description_links)\n		test_player = entity.Entity(1, 1, 'A', libtcod.white, identified=test_identified_component)\n		test_potion = make_healing_potion()\n		self.assertEqual(test_potion.consumable.consumable_type, ConsumableTypes.POTION)\n		self.assertEqual(test_potion.name.true_name, \"Healing Potion\")\n		self.assertEqual(get_display_name(test_player, test_potion), potion_description_links[test_potion.name.true_name])\n\n	def test_identified_scroll_has_correct_display_name(self):\n		constants = get_constants()\n		scroll_description_links = assign_scroll_descriptions(constants['scroll_descriptions'], constants['scroll_types'])\n		potion_description_links = assign_potion_descriptions(constants['potion_descriptions'], constants['potion_types'])\n		test_identified_component = Identified(potion_description_links, scroll_description_links)\n		test_identified_component.identified_scrolls.append(\"Confusion Scroll\")\n		test_player = entity.Entity(1, 1, 'A', libtcod.white, identified=test_identified_component)\n		test_scroll = make_confusion_scroll()\n		self.assertEqual(test_scroll.name.true_name, \"Confusion Scroll\")\n		self.assertTrue(\"Confusion Scroll\" in test_player.identified.identified_scrolls)\n		self.assertEqual(get_display_name(test_player, test_scroll), \"Confusion Scroll\")\n\n	def test_unidentified_scroll_has_correct_display_name(self):\n		constants = get_constants()\n		potion_description_links = assign_potion_descriptions(constants['potion_descriptions'], constants['potion_types'])\n		scroll_description_links = assign_scroll_descriptions(constants['scroll_descriptions'], constants['scroll_types'])\n		test_identified_component = Identified(potion_description_links, scroll_description_links)\n		test_player = entity.Entity(1, 1, 'A', libtcod.white, identified=test_identified_component)\n		test_scroll = make_confusion_scroll()\n		self.assertEqual(test_scroll.consumable.consumable_type, ConsumableTypes.SCROLL)\n		self.assertEqual(test_scroll.name.true_name, \"Confusion Scroll\")\n		self.assertEqual(get_display_name(test_player, test_scroll), scroll_description_links[test_scroll.name.true_name])\n\n	def test_using_an_unidentified_scroll_identifies_it(self):\n		constants = get_constants()\n		potion_description_links = assign_potion_descriptions(constants['potion_descriptions'], constants['potion_types'])\n		scroll_description_links = assign_scroll_descriptions(constants['scroll_descriptions'], constants['scroll_types'])\n		test_identified_component = Identified(potion_description_links, scroll_description_links)\n		test_inventory = Inventory(10)\n		test_player = entity.Entity(1, 1, 'A', libtcod.white, identified=test_identified_component, inventory=test_inventory)\n		test_scroll = make_confusion_scroll()\n		self.assertEqual(len(test_identified_component.identified_scrolls), 0)\n		test_inventory.use(test_scroll)\n		self.assertEqual(len(test_identified_component.identified_scrolls), 1)\n		#self.assertTrue('onfusion' in test_identified_component.identified_scrolls)\n\nclass BasicGameTests(unittest.TestCase):\n	def test_can_create_new_game(self):\n		constants = get_constants()\n		player, entities, game_map, message_log, game_state, dlevels = get_game_variables(constants)\n		self.assertEqual(isinstance(entities, list), True)\n\n	def test_can_save_game(self):\n		constants = get_constants()\n		player, entities, game_map, message_log, game_state, dlevels = get_game_variables(constants)\n		self.assertEqual(save_game(player, entities, game_map, message_log, game_state, dlevels), True)\n\n	def test_can_load_game(self):\n		constants = get_constants()\n		player, entities, game_map, message_log, game_state, dlevels = get_game_variables(constants)\n		save_game(player, entities, game_map, message_log, game_state, dlevels)\n		player, entities, game_map, message_log, game_state, dlevels = load_game()\n		self.assertEqual(isinstance(entities, list), True)		\n\n	def test_game_starts_with_turn_count(self):\n		constants = get_constants()\n		player, entities, game_map, message_log, game_state, dlevels = get_game_variables(constants)\n		self.assertEqual(game_state.game_turn, 0)\n\nclass CharacterTests(unittest.TestCase):\n	def test_can_create_character_with_stats(self):\n		constants = get_constants()\n		player, entities, game_map, message_log, game_state, dlevels = get_game_variables(constants)\n		self.assertTrue(player.stats)\n	def test_can_create_character_with_correct_stats(self):\n		constants = get_constants()\n		player, entities, game_map, message_log, game_state, dlevels = get_game_variables(constants)\n		self.assertTrue(player.stats.Strength, 16)\n\n	def test_can_create_priest(self):\n		constants = get_constants()\n		test_priest = create_player(constants, 3)\n		# TODO: There must be a better way to test this\n		self.assertEqual(test_priest.stats.Strength, 13)\n\n	def test_can_create_wizard(self):\n		constants = get_constants()\n		test_wizard = create_player(constants, 2)\n		# TODO: There must be a better way to test this\n		self.assertEqual(test_wizard.stats.Intellect, 18)	\n\n	def test_can_get_character_race(self):\n		race = get_character_race(con, constants)\n		\n\nclass EffectsTests(unittest.TestCase):\n\n	def test_effects_manager_can_add_effect(self):\n		test_fighter = Fighter(xp_reward=100)\n		test_entity = entity.Entity(1, 1, 'A', libtcod.white, fighter=test_fighter)\n		test_effect = Effect(name=EffectNames.POISON, description=\"Poisoned\", turns_left=5, damage_per_turn=3)\n		self.assertEqual(add_effect(test_effect, test_entity), \"appended\")\n		self.assertEqual(len(test_fighter.effect_list), 1)\n\n	def test_effects_stack_properly(self):\n		test_fighter = Fighter(xp_reward=100)\n		test_entity = entity.Entity(1, 1, 'A', libtcod.white, fighter=test_fighter)\n		test_effect = Effect(name=EffectNames.POISON, description=\"Poisoned\", turns_left=5, damage_per_turn=3)\n		add_effect(test_effect, test_entity)\n		test_effect_2 = Effect(name=EffectNames.POISON, description=\"Poisoned\", turns_left=3, damage_per_turn=3)\n		self.assertEqual(add_effect(test_effect_2, test_entity), \"extended\")\n		self.assertEqual(test_fighter.effect_list[0].turns_left, 8)\n\n	def test_effects_tick_down(self):\n		test_fighter = Fighter(xp_reward=100)\n		test_entity = entity.Entity(1, 1, 'A', libtcod.white, fighter=test_fighter)\n		test_effect = Effect(name=EffectNames.POISON, description=\"Poisoned\", turns_left=5, damage_per_turn=3)\n		add_effect(test_effect, test_entity)\n		tick_down_effects(test_entity)\n		self.assertEqual(test_effect.turns_left, 4)\n\n	def test_effects_disappear_when_done(self):\n		test_fighter = Fighter(xp_reward=100)\n		test_entity = entity.Entity(1, 1, 'A', libtcod.white, fighter=test_fighter)\n		test_effect = Effect(name=EffectNames.POISON, description=\"Poisoned\", turns_left=5, damage_per_turn=3)\n		add_effect(test_effect, test_entity)\n		self.assertEqual(len(test_entity.fighter.effect_list), 1)\n		for _ in range(5):\n			tick_down_effects(test_entity)\n		self.assertEqual(len(test_entity.fighter.effect_list), 0)\n\n	def test_damage_over_time_effects_work(self):\n		fighter_component = Fighter(xp_reward=100)\n		stats_component = Stats(Strength=9, Precision=11, Agility=12, Intellect=10, Willpower=9, Stamina=10, Endurance=9)\n		test_entity = entity.Entity(1, 1, 'A', libtcod.white, stats=stats_component, fighter=fighter_component)\n		test_effect = Effect(name=EffectNames.POISON, description=\"Poisoned\", turns_left=5, damage_per_turn=3)\n		add_effect(test_effect, test_entity)\n		process_damage_over_time(test_entity)\n		self.assertEqual(test_entity.stats.hp, 16)\n\n	def test_can_calculate_hit_bonus_from_effects(self):\n		test_fighter = Fighter(xp_reward=100)\n		test_entity = entity.Entity(1, 1, 'A', libtcod.white, fighter=test_fighter)\n		test_effect = Effect(name=EffectNames.POISON, description=\"Poisoned\", turns_left=5, damage_per_turn=3)\n		add_effect(test_effect, test_entity)\n		self.assertEqual(get_hit_modifier_from_status_effects(test_entity), 0)\n		test_effect_2 = Effect(name=EffectNames.BLESS, description=\"Blessed\", turns_left=5, hit_modifier=3)\n		add_effect(test_effect_2, test_entity)\n		self.assertEqual(get_hit_modifier_from_status_effects(test_entity), 3)\n\n	def test_can_calculate_damage_bonus_from_effects(self):\n		test_fighter = Fighter(xp_reward=100)\n		test_entity = entity.Entity(1, 1, 'A', libtcod.white, fighter=test_fighter)\n		self.assertEqual(get_physical_damage_modifier_from_status_effects(test_entity), 0)\n		test_effect = Effect(name=EffectNames.BLESS, description=\"Blessed\", turns_left=5, physical_damage_modifier=3)\n		add_effect(test_effect, test_entity)\n		self.assertEqual(get_physical_damage_modifier_from_status_effects(test_entity), 3)\n\n	def test_can_apply_a_confuse_effect(self):\n		test_player = mocks.create_mockchar_3()\n		test_effect = Effect(name=EffectNames.CONFUSION, description=\"Confused\", turns_left=5)\n		add_effect(test_effect, test_player)\n		self.assertEqual(test_player.fighter.effect_list[0].name, EffectNames.CONFUSION)\n\n\nclass UseTests(unittest.TestCase):\n	def test_can_use_healing_potion(self):\n		test_potion = make_healing_potion()\n		test_inventory = Inventory(10)\n		test_player_entity = entity.Entity(1, 1, 'A', libtcod.white, \"Player\", inventory=test_inventory)\n		results = test_inventory.use(test_potion)\n		self.assertEqual(len(results), 1)\n\n	def test_can_identify_a_potion(self):\n		test_char = mocks.create_mockchar_1()\n		self.assertEqual(len(test_char.identified.identified_potions), 0)\n		test_potion = make_healing_potion()\n		results = test_char.inventory.use(test_potion)\n		self.assertEqual(len(test_char.identified.identified_potions), 1)\n\n	def test_can_use_confusion_potion(self):\n		test_potion = make_confusion_potion()\n		test_inventory = Inventory(10)\n		test_inventory.items.append(test_potion)\n		test_player_entity = entity.Entity(1, 1, 'A', libtcod.white, \"Player\", inventory=test_inventory)\n		test_inventory.use(test_potion)\n		#self.assertEqual(results[0].get('consumed'), True)\n\nclass MoveTests(unittest.TestCase):\n	def test_can_calculate_distance_to(self):\n		test_entity_1 = entity.Entity(1, 1, 'A', libtcod.white)\n		test_entity_2 = entity.Entity(4, 5, 'A', libtcod.white)\n		self.assertEqual(distance_to(test_entity_1, test_entity_2), 5)\n\nclass BookTests(unittest.TestCase):\n	def test_can_make_and_hold_bless_book(self):\n		test_book = make_bless_book()\n		test_inventory = Inventory(10)\n		test_entity = entity.Entity(1, 1, 'A', libtcod.white, inventory=test_inventory)\n		test_inventory.add_item(test_book)\n		self.assertTrue(len(test_inventory.items) == 1)\n		self.assertEqual(test_inventory.items[0].name.true_name, \"Bless spellbook\")\n\nclass PotionMenuTests(unittest.TestCase):\n	def test_can_produce_list_of_potions_for_menu(self):\n		test_potion = make_healing_potion()\n		test_potion2 = make_poison_potion()\n		test_inventory = Inventory(10)\n		test_inventory.items.append(test_potion)\n		test_inventory.items.append(test_potion2)\n		test_player = entity.Entity(1, 1, 'A', libtcod.white, inventory=test_inventory)\n		potions = get_carried_potions(test_player)\n		self.assertEqual(len(potions), 2)\n\n	def test_can_quaff_potion(self):\n		test_potion = make_healing_potion()\n		test_potion2 = make_poison_potion()\n		test_inventory = Inventory(10)\n		test_inventory.items.append(test_potion)\n		test_inventory.items.append(test_potion2)\n		test_player = entity.Entity(1, 1, 'A', libtcod.white, inventory=test_inventory)\n		potions = get_carried_potions(test_player)\n		used_potion = potions[0]\n		player_turn_results = []\n		player_turn_results.extend(test_player.inventory.use(used_potion))\n		self.assertNotEqual(player_turn_results, 0)\n\nclass PickupTests(unittest.TestCase):\n	def test_can_pickup_item(self):\n		test_bow = EquippableFactory.make_shortbow()\n		test_inventory = Inventory(10)\n		test_player = entity.Entity(1, 1, 'A', libtcod.white, inventory=test_inventory)\n		entities = []\n		entities.append(test_player)\n		entities.append(test_bow)\n		player_turn_results = []\n		player_turn_results.extend(pickup_item(test_player, entities))\n		self.assertTrue('item_added' in player_turn_results[0])\n\n	def test_picking_up_can_stack_quantity(self):\n		test_inventory = Inventory(10)\n		test_player = entity.Entity(1, 1, 'A', libtcod.white, inventory=test_inventory)\n		self.assertEqual(len(test_player.inventory.items), 0)\n		test_arrows = EquippableFactory.make_arrows(1, 1, 5)\n		test_player.inventory.items.append(test_arrows)\n		self.assertEqual(test_player.inventory.items[0].item.quantity, 5)\n		self.assertEqual(len(test_player.inventory.items), 1)\n		test_arrows_2 = EquippableFactory.make_arrows(1,1, 2)\n		test_player.inventory.add_item(test_arrows_2)\n		self.assertEqual(len(test_player.inventory.items), 1)\n		self.assertEqual(test_player.inventory.items[0].item.quantity, 7)\n\nclass FeatTests(unittest.TestCase):\n	def test_can_get_current_feats(self):\n		test_performer = Performer()\n		test_player = entity.Entity(1, 1, 'A', libtcod.white, performer=test_performer)\n		self.assertEqual(len(test_player.performer.feat_list), 0)\n\n	def test_can_get_targetable_entities(self):\n		test_player_fighter = Fighter()\n		test_player = entity.Entity(1, 1, 'A', libtcod.white, fighter=test_player_fighter)\n		fighter_component = Fighter()\n		test_monster = entity.Entity(1, 0, 'B', libtcod.white, fighter=fighter_component)\n		entities = [test_player, test_monster]\n		self.assertEqual(len(get_targetable_entities_in_range(test_player, 5, entities)), 1)\n\n	def test_can_get_available_feats(self):\n		pass\n\n	def test_can_learn_unlocked_feat(self):\n		pass\n\n	def test_cannot_learn_locked_feat(self):\n		pass\n\nclass DRTests(unittest.TestCase):\n	def test_can_get_base_DR(self):\n		test_equipment = Equipment()\n		test_fighter = Fighter()\n		test_player = test_player = entity.Entity(1, 1, 'A', libtcod.white, fighter=test_fighter, equipment=test_equipment)\n		self.assertEqual(test_player.fighter.DR, 0)\n		test_fighter2 = Fighter(base_DR=2)\n		test_player2 = entity.Entity(1, 1, 'A', libtcod.white, fighter=test_fighter2, equipment=test_equipment)\n		self.assertEqual(test_player2.fighter.DR, 2)\n\n	def test_can_get_DR_from_equipment(self):\n		test_equipment = Equipment()\n		test_fighter = Fighter()\n		test_player = test_player = entity.Entity(1, 1, 'A', libtcod.white, fighter=test_fighter, equipment=test_equipment)\n		self.assertEqual(test_player.fighter.DR, 0)\n		test_armor = EquippableFactory.make_padded_armor()\n		test_equipment.body = test_armor\n		self.assertEqual(test_player.fighter.DR, 1)\n\n\nif __name__ == \"__main__\":\n	unittest.main()\n",
			"file": "rltests.py",
			"file_size": 46166,
			"file_write_time": 132667332511770138,
			"settings":
			{
				"buffer_size": 45315,
				"line_ending": "Windows"
			}
		},
		{
			"file": "loader_functions/constants.py",
			"settings":
			{
				"buffer_size": 2659,
				"line_ending": "Windows"
			}
		},
		{
			"file": "components/equippable.py",
			"settings":
			{
				"buffer_size": 9486,
				"line_ending": "Windows"
			}
		},
		{
			"file": "components/equipment.py",
			"settings":
			{
				"buffer_size": 6474,
				"line_ending": "Windows"
			}
		},
		{
			"file": "character.py",
			"settings":
			{
				"buffer_size": 530,
				"line_ending": "Windows"
			}
		},
		{
			"file": "race.py",
			"settings":
			{
				"buffer_size": 507,
				"line_ending": "Windows"
			}
		},
		{
			"file": "engine.py",
			"settings":
			{
				"buffer_size": 5811,
				"line_ending": "Windows"
			}
		},
		{
			"file": "loader_functions/initialize_new_game.py",
			"settings":
			{
				"buffer_size": 7047,
				"line_ending": "Windows"
			}
		},
		{
			"file": "menus.py",
			"settings":
			{
				"buffer_size": 8993,
				"line_ending": "Windows"
			}
		},
		{
			"file": "render_functions.py",
			"settings":
			{
				"buffer_size": 6675,
				"line_ending": "Windows"
			}
		},
		{
			"file": "entity.py",
			"settings":
			{
				"buffer_size": 2145,
				"line_ending": "Windows"
			}
		},
		{
			"file": "systems/input_process_system.py",
			"settings":
			{
				"buffer_size": 8075,
				"line_ending": "Windows"
			}
		},
		{
			"file": "systems/results_process_system.py",
			"settings":
			{
				"buffer_size": 5240,
				"line_ending": "Windows"
			}
		},
		{
			"file": "input_handlers.py",
			"settings":
			{
				"buffer_size": 5657,
				"line_ending": "Windows"
			}
		},
		{
			"file": "spells.py",
			"settings":
			{
				"buffer_size": 349,
				"line_ending": "Windows"
			}
		},
		{
			"file": "components/caster.py",
			"settings":
			{
				"buffer_size": 302,
				"line_ending": "Windows"
			}
		},
		{
			"file": "systems/spell_system.py",
			"settings":
			{
				"buffer_size": 2601,
				"line_ending": "Windows"
			}
		},
		{
			"file": "systems/skill_manager.py",
			"settings":
			{
				"buffer_size": 2068,
				"line_ending": "Windows"
			}
		},
		{
			"file": "components/skills.py",
			"settings":
			{
				"buffer_size": 724,
				"line_ending": "Windows"
			}
		},
		{
			"file": "components/inventory.py",
			"settings":
			{
				"buffer_size": 3471,
				"line_ending": "Windows"
			}
		},
		{
			"file": "generators.py",
			"settings":
			{
				"buffer_size": 938,
				"line_ending": "Windows"
			}
		},
		{
			"file": "map_objects/game_map.py",
			"settings":
			{
				"buffer_size": 7704,
				"line_ending": "Windows"
			}
		},
		{
			"file": "components/item.py",
			"settings":
			{
				"buffer_size": 104,
				"line_ending": "Windows"
			}
		},
		{
			"file": "item_factory.py",
			"settings":
			{
				"buffer_size": 3859,
				"line_ending": "Windows"
			}
		},
		{
			"file": "magic_functions.py",
			"settings":
			{
				"buffer_size": 6668,
				"line_ending": "Windows"
			}
		},
		{
			"file": ".gitignore",
			"settings":
			{
				"buffer_size": 26,
				"line_ending": "Windows"
			}
		}
	],
	"build_system": "",
	"command_palette":
	{
		"height": 392.0,
		"selected_items":
		[
		],
		"width": 392.0
	},
	"console":
	{
		"height": 0.0
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"file_history":
	[
		"/C/dev/p3roguelike/engine.py",
		"/C/dev/p3roguelike/random_utils.py",
		"/C/dev/p3roguelike/components/name.py",
		"/C/dev/p3roguelike/components/performer.py",
		"/C/dev/p3roguelike/feats.py",
		"/C/dev/p3roguelike/systems/feat_system.py",
		"/C/dev/p3roguelike/systems/attack.py",
		"/C/dev/p3roguelike/components/defender.py",
		"/C/dev/p3roguelike/systems/move_system.py",
		"/C/dev/p3roguelike/death_functions.py",
		"/C/dev/p3roguelike/monsters.py",
		"/C/dev/p3roguelike/systems/effects_manager.py",
		"/C/dev/p3roguelike/systems/time_system.py",
		"/C/dev/p3roguelike/loader_functions/tile_codes.py",
		"/C/dev/p3roguelike/systems/name_system.py",
		"/C/dev/p3roguelike/components/stats.py",
		"/C/dev/p3roguelike/mocks.py",
		"/C/dev/p3roguelike/components/fighter.py",
		"/C/dev/p3roguelike/components/level.py",
		"/C/dev/p3roguelike/components/ai.py",
		"/C/dev/p3roguelike/.git/COMMIT_EDITMSG",
		"/C/dev/p3roguelike/render_functions.py",
		"/C/dev/p3roguelike/targeting.py",
		"/C/dev/p3roguelike/systems/pickup_system.py",
		"/C/dev/p3roguelike/entity.py",
		"/C/dev/p3roguelike/game_states.py",
		"/C/dev/p3roguelike/game_state.py",
		"/C/dev/p3roguelike/map_objects/game_map.py",
		"/C/dev/p3roguelike/p3RL.sublime-workspace",
		"/C/dev/p3roguelike/systems/damage.py",
		"/C/Users/Leon/Documents/steem",
		"/C/dev/p3roguelike/components/effects.py",
		"/C/dev/p3roguelike/components/meleeweapon.py",
		"/C/dev/p3roguelike/components/missileweapon.py",
		"/C/dev/p3roguelike/components/equipment.py",
		"/C/dev/p3roguelike/components/equippable.py",
		"/C/dev/p3roguelike/attack_types.py",
		"/C/dev/p3roguelike/components/identified.py",
		"/C/dev/p3roguelike/components/ammunition.py",
		"/C/dev/p3roguelike/equipment_slots.py",
		"/C/dev/p3roguelike/components/feats.py",
		"/C/dev/p3rl-copy/engine.py",
		"/C/dev/microblog/microblog.py",
		"/C/dev/microblog/app/templates/index.html",
		"/C/dev/microblog/app/templates/base.html",
		"/C/dev/microblog/app/routes.py",
		"/C/dev/microblog/.flaskenv",
		"/C/dev/microblog/app/__init__.py",
		"/C/dev/microblog/config.py",
		"/C/dev/microblog/app/forms.py",
		"/C/dev/p3roguelike/systems/skill_manager.py",
		"/C/dev/str.py",
		"/C/dev/p3roguelike - Copy/systems/move_system.py",
		"/C/dev/ClonedRL/atrl-master/main.py",
		"/C/dev/p3roguelike/damage_types.py",
		"/C/dev/p3roguelike/spells.py",
		"/C/dev/p3rl-copy/components/fighter.py",
		"/C/dev/p3roguelike - Copy/systems/input_process_system.py",
		"/C/dev/p3rl-copy/systems/results_process_system.py",
		"/C/dev/p3roguelike-base/engine.py",
		"/C/dev/ClonedRL/atrl-master/game/loader_functions/tiles.py",
		"/C/dev/ClonedRL/atrl-master/game/render_functions.py",
		"/C/dev/ClonedRL/atrl-master/game/death_functions.py",
		"/C/dev/ClonedRL/atrl-master/game/entity.py",
		"/C/dev/ClonedRL/atrl-master/game/map_objects/game_map.py",
		"/C/dev/ClonedRL/atrl-master/game/loader_functions/initialize_new_game.py",
		"/C/dev/p3roguelike/input_process_system.py",
		"/C/dev/p3roguelike/systems/pickup_system",
		"/C/dev/p3roguelike/components/inventory.py",
		"/C/dev/ClonedRL/atrl-master/game/menus.py",
		"/C/dev/p3roguelike/components/consumable.py",
		"/C/dev/jsrl/jsrl.html",
		"/C/dev/p3roguelike/main.py",
		"/C/dev/p3roguelike/potion_test.py",
		"/C/dev/p3roguelike/components/skills.py",
		"/C/dev/p3roguelike/menu_options.py",
		"/C/dev/p3roguelike/loader_functions/data_loaders.py",
		"/C/dev/p3roguelike/generators.py",
		"/C/dev/p3roguelike/input_handlers.py",
		"/C/dev/p3roguelike/game_messages.py",
		"/C/dev/p3roguelike/dlevel.py",
		"/C/dev/p3roguelike/components/stairs.py",
		"/C/workspace/pingpong/index.html",
		"/C/dev/p3roguelike/identified.py",
		"/C/dev/property.py",
		"/C/dev/p3roguelike/fov_functions.py",
		"/C/dev/p3roguelike/loader_functions/skill_book.py",
		"/C/dev/p3roguelike/components/caster.py",
		"/C/dev/p3roguelike/rltests.py",
		"/C/dev/p3roguelike/rltests2.py",
		"/C/dev/test.py",
		"/C/dev/p3roguelike-base/components/fighter.py",
		"/C/dev/p3roguelike/monsters",
		"/C/dev/animal.html",
		"/C/dev/rock.html",
		"/C/dev/pong/pong3.html",
		"/C/dev/p3roguelike/map_objects/rectangle.py",
		"/C/dev/p3roguelike-base/map_objects/game_map.py",
		"/C/dev/p3roguelike/loader_functions/initialize_new_game.py",
		"/C/dev/p3roguelike/map_objects/tile.py",
		"/C/dev/p3roguelike/components/level",
		"/C/workspace/pingpong/js/pingpong.js",
		"/C/dev/simple.py",
		"/C/dev/p3roguelike/components/__init__.py",
		"/C/workspace/pingpong/css/pingpong.css",
		"/C/Users/Leon/AppData/Local/Programs/Python/Python36-32/Lib/site-packages/linkedin/server.py",
		"/C/workspace/linkedin/posts.txt",
		"/C/workspace/linkedin/linkedinapp3.py",
		"/C/workspace/linkedin/linkedinapp.py",
		"/C/dev/p3roguelike/map_objects/__init__.py",
		"/C/workspace/linkedin/Best supplements to naturally boost testosterone",
		"/C/Users/Leon/Documents/Emoji/Emoji",
		"/C/workspace/round.py",
		"/C/dev/tweeter/newTweeterEU.py",
		"/C/Users/Leon/Documents/Business/SurveyAspirations",
		"/C/dev/tweeter/tracker.py",
		"/C/workspace/tweetbot/blogTweets.txt",
		"/C/workspace/tweetbot/articleTweets.txt",
		"/C/dev/linkstrip/linkstrip/sourcelinks.txt",
		"/C/dev/linkstrip/linkstrip/targetlinks.txt",
		"/C/Users/Leon/AppData/Local/Temp/Temp1_rltut03.zip/rl tut 03/src/rltut/WorldBuilder.java",
		"/C/Users/Leon/AppData/Local/Temp/Temp1_rltut03 (1).zip/rl tut 03/src/rltut/screens/PlayScreen.java",
		"/C/Users/Leon/AppData/Local/Temp/Temp1_rltut03 (1).zip/rl tut 03/src/rltut/Tile.java",
		"/C/workspace/pygame/game2.py",
		"/C/workspace/pygame/game1.py",
		"/C/workspace/RLtdl/input_handlers.py",
		"/C/workspace/RLtdl/render_functions.py",
		"/C/workspace/RLtdl/components/ai.py"
	],
	"find":
	{
		"height": 34.0
	},
	"find_in_files":
	{
		"height": 0.0,
		"where_history":
		[
			"C:\\dev\\p3roguelike",
			"<open files>,C:\\dev\\p3roguelike",
			"<open files>",
			"C:\\Users\\Leon\\Downloads\\rltut09\\rl tut 09\\src\\rltut",
			"C:\\Users\\Leon\\AppData\\Local\\Temp\\Temp1_rltut09.zip\\rl tut 09\\src\\rltut"
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"root",
			"DEATH OF",
			"con",
			"charac",
			"character",
			"print(",
			"tomb of the",
			"tomb of",
			"tomb of the",
			"lightning_scroll",
			"lightn",
			"const",
			"TODO",
			"make_long",
			"make_great",
			"TODO",
			"heal(",
			"TODO",
			"fighter.current_targeting_weapon",
			"current_targeting_spell",
			"spell_targeting",
			"spell_target",
			"current_targeting_weapon",
			"TODO",
			"cast_lightn",
			"is hit for",
			"make_firebo",
			"get_skill_check",
			"get_weapon_sk",
			"skill_check_l",
			"character",
			"is not None",
			"staff",
			"mark_equip",
			"get_str",
			"base_max",
			"print(",
			"player",
			"level",
			"death_func",
			"process_entity_turn",
			"character_scr",
			"scroll_ty",
			"character_screen(",
			"get_equip",
			"mark_eq",
			"unspent",
			"unsp",
			"level",
			"self.own",
			"dead_ent",
			"dead",
			"dea",
			"handle_dea",
			"dead_entity",
			"kill_monster(",
			"kill_mon",
			"kill_monster",
			"kill_m",
			"kill_mons",
			"take",
			"take_stairs",
			"level",
			"lightning",
			"lightning_scroll",
			"cast_lightning",
			"there is no valid target there",
			"there!!!",
			"there is no valid",
			"game_state =",
			"holy",
			"storm",
			"lightning_bolt",
			"lightning_bolt_spell",
			"lightning",
			"cast_lightning",
			"lightning",
			"get_equipped_it",
			"get_game_v",
			"sword",
			"start_equi",
			"exit",
			"name",
			"player",
			"performed",
			"perform",
			"performed",
			"item_cons",
			"game_state.current_g",
			"spell_targ",
			"spell_tar",
			"loaded",
			"attempt_move",
			"attempt_move_e",
			"game_state",
			"item_added",
			"game_state",
			"game_st",
			"cannot_get",
			"heal",
			"poison",
			"healing",
			"heal",
			"get_ch",
			"main_menu",
			"you pick up the",
			"wait",
			"message",
			"you pick up the",
			"finishing t",
			"spells_index",
			"spells_screen",
			"you fail to cast",
			"item_functions",
			"damage_dice",
			"feat",
			"feat_targeting",
			"there are no valid",
			"if targeting",
			"pick up the",
			"dlevels",
			"player_dead",
			"xp",
			"state",
			"current_targeting_spel",
			"current_targeting_mis",
			"missile_targ",
			"fire_weapon"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
			"make_troll",
			"make_kobold",
			"make_orc",
			"xp_reward",
			"melee_damage",
			"d6_dice_roll",
			"action_free = False",
			"entity",
			"SkillNames.SHIELD",
			"SkillNames.SWORD",
			"entity.fighter.effect_list",
			"make_longsword",
			"make_shortbow",
			"make_longsword",
			"scroll",
			"hit_modifier",
			"damage_modifier",
			"move_system",
			"target.name",
			"true_name",
			"make_heal_book",
			"make_fireball_book",
			"make_confusion_scroll",
			"make_lightning_scroll",
			"make_fireball_scroll",
			"make_poison_potion",
			"make_sword",
			"make_bolts",
			"make_sword",
			"make_leather_armor",
			"make_dagger",
			"make_crossbow",
			"make_bow",
			"make_shield",
			"make_arrows",
			"set_skill_rank",
			"set_skill",
			"get_skill",
			"set_skill",
			"evade",
			"PIERCING",
			"SLASHING",
			"missile",
			"dice_roll",
			"get_block",
			"get_dodge",
			"get_parry",
			"self.owner.stats",
			"PD",
			"",
			" Testosterone ",
			"Testosterone",
			"",
			"    ",
			"https://www.extremeuncertainty.com",
			"",
			"hair",
			"teeth",
			"eyes",
			"weight",
			"height",
			"age",
			"name"
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 6,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "rltests.py",
					"settings":
					{
						"buffer_size": 45315,
						"regions":
						{
						},
						"selection":
						[
							[
								36050,
								36050
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 15444.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "loader_functions/constants.py",
					"settings":
					{
						"buffer_size": 2659,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 444.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "components/equippable.py",
					"settings":
					{
						"buffer_size": 9486,
						"regions":
						{
						},
						"selection":
						[
							[
								424,
								424
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "components/equipment.py",
					"settings":
					{
						"buffer_size": 6474,
						"regions":
						{
						},
						"selection":
						[
							[
								2087,
								2087
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "character.py",
					"settings":
					{
						"buffer_size": 530,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 5,
					"file": "race.py",
					"settings":
					{
						"buffer_size": 507,
						"regions":
						{
						},
						"selection":
						[
							[
								484,
								484
							]
						],
						"settings":
						{
							"auto_name": "",
							"syntax": "Packages/Python/Python.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 6,
					"file": "engine.py",
					"settings":
					{
						"buffer_size": 5811,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 988.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 7,
					"file": "loader_functions/initialize_new_game.py",
					"settings":
					{
						"buffer_size": 7047,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 2579.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 8,
					"file": "menus.py",
					"settings":
					{
						"buffer_size": 8993,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 1347.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 9,
					"file": "render_functions.py",
					"settings":
					{
						"buffer_size": 6675,
						"regions":
						{
						},
						"selection":
						[
							[
								4790,
								4791
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 1061.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 10,
					"file": "entity.py",
					"settings":
					{
						"buffer_size": 2145,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 11,
					"file": "systems/input_process_system.py",
					"settings":
					{
						"buffer_size": 8075,
						"regions":
						{
						},
						"selection":
						[
							[
								4859,
								4868
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 1831.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 12,
					"file": "systems/results_process_system.py",
					"settings":
					{
						"buffer_size": 5240,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 13,
					"file": "input_handlers.py",
					"settings":
					{
						"buffer_size": 5657,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 3830.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 14,
					"file": "spells.py",
					"settings":
					{
						"buffer_size": 349,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 15,
					"file": "components/caster.py",
					"settings":
					{
						"buffer_size": 302,
						"regions":
						{
						},
						"selection":
						[
							[
								294,
								294
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 16,
					"file": "systems/spell_system.py",
					"settings":
					{
						"buffer_size": 2601,
						"regions":
						{
						},
						"selection":
						[
							[
								834,
								834
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 924.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 17,
					"file": "systems/skill_manager.py",
					"settings":
					{
						"buffer_size": 2068,
						"regions":
						{
						},
						"selection":
						[
							[
								350,
								350
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 18,
					"file": "components/skills.py",
					"settings":
					{
						"buffer_size": 724,
						"regions":
						{
						},
						"selection":
						[
							[
								53,
								53
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 19,
					"file": "components/inventory.py",
					"settings":
					{
						"buffer_size": 3471,
						"regions":
						{
						},
						"selection":
						[
							[
								136,
								136
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 20,
					"file": "generators.py",
					"settings":
					{
						"buffer_size": 938,
						"regions":
						{
						},
						"selection":
						[
							[
								85,
								87
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.tmLanguage"
						},
						"translation.x": 80.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 21,
					"file": "map_objects/game_map.py",
					"settings":
					{
						"buffer_size": 7704,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 3804.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 22,
					"file": "components/item.py",
					"settings":
					{
						"buffer_size": 104,
						"regions":
						{
						},
						"selection":
						[
							[
								104,
								104
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 23,
					"file": "item_factory.py",
					"settings":
					{
						"buffer_size": 3859,
						"regions":
						{
						},
						"selection":
						[
							[
								92,
								92
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 24,
					"file": "magic_functions.py",
					"settings":
					{
						"buffer_size": 6668,
						"regions":
						{
						},
						"selection":
						[
							[
								776,
								776
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 132.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 25,
					"file": ".gitignore",
					"settings":
					{
						"buffer_size": 26,
						"regions":
						{
						},
						"selection":
						[
							[
								26,
								26
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 0.0
	},
	"input":
	{
		"height": 0.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"replace":
	{
		"height": 62.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 500.0,
		"selected_items":
		[
		],
		"width": 380.0
	},
	"show_minimap": true,
	"show_open_files": true,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 287.0,
	"status_bar_visible": true
}
